# なぜジェネリクスは非変なのか

変性という概念があり、これは参照型をどの型として扱えるようにするかという性質のこと。3つの種類がある。
- 共変性：サブクラスの代入を許す（ポリモーフィズムが実現できている理由）
- 非変性：サブクラスの代入を許さない
- 反変性：スーパークラスの代入を許す

もともと、共変性だけをサポートしていたが、これには問題があたった。<br>例えば、以下のコードは実行時エラーが出る。
```java
String[] strArray = {"A","B"};
Object[] objctArray = strArray; //代入できる
objctArray[0] = Integer.valueOf(1); //コンパイルはできる
```
なぜかというと、strArrayは共変性の仕組みでobjectArrayに参照を代入しているが、この中身の配列自体はString型だけを扱うものであり、Integer型の参照を代入することはできないため。

これは安全ではないことから、ジェネリクスが導入されるタイミングで非変性を導入した。ちなみに、配列は互換性を考慮して共変となっている。

ジェネリクスが非変であるというのは、以下のような場合にコンパイルエラーが出るということ。
```java
List<Object> list = new ArrayList<String>();
```
仮にこれが許されれば以下は許容されることになるが、実行時エラーが出る。
```java
list.add(100); //ボクシングでIntegerの参照が入る
```
やはり共変は安全ではない（共変自体が問題ということではない）。ジェネリクスが非変であることはこのような背景がある。

[トップへ戻る](../../../../../../../README.md)