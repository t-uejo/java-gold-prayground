# 下限境界ワイルドカードと上限と下限をどう使い分けるか

非境界ワイルドカードには2つの特徴があると[前回](../q6/README.md)書いた。
1. メソッドの戻り値型はObject型になる
2. メソッドの引数にはnullリテラルしか渡せない

また、上限境界ワイルドカードは、**戻り値を特定することができるが、引数は渡せない**ということも[前回](../q8/README.md)書いた。今回は、下限境界ワイルドカードについて触れ、上限と下限のワイルドカードをどう使い分けるかについて見ていく。クラスやコレクションの汎用性を上げるには必ず必要な知識である。

## 下限境界ワイルドカードについて
```java
public class Test<T> {
    private T value;

    public Test(T value) {
        this.value = value;
    }
    
    public T setValue(T value) {
        this.value = value;
    }
    
    public T getValue() {
        return value;
    }
}
```

上記クラスを以下のように下限境界ワイルドカードを使ってインスタンス化する。なお、BはAのサブクラスである。

```java
Test<? super B> a = new Test<A>(new A());

Object objA = a.getValue(); //戻り型はObject型

a.setValue(new B());
a.setValue(new A()); //コンパイルエラー
```

まず、3行目の`getValue`では、戻り値がObject型となる。この理由は、Testクラスのフィールド`value`の型が`<? super B>`となっており、Bよりも抽象となる型が返ってくるためである。

例えば、B型の場合もあれば、A型の場合もあるし、Object型の可能性もある。そのため、一番抽象度の高いObject型を返す。

5行目の`setValue`について、Testクラスのフィールドの型`<? super B>`には、B型よりも必ず抽象度の高いインスタンスが入ることが保証されている。そのため、Bもしくは、Bのサブクラスであれば、共変により互換性が保証されるため、引数に渡すことができる。

しかし、6行目のように、A型のインスタンスは渡せない。これも不定となるためである。Bかもしれないし、より上位の型が入る場合があり、保証することはできない。

このように、上限境界ワイルドカードとは逆の性質を持つことになる。

## 上限と下限をどう使い分けるか

PECSという原則がある。

インスタンス化したオブジェクトのメソッドが、戻り値を戻す提供者（Producer）であればextendsを使い、引数を受け取って利用する消費者（Consumer）であれば、superを使うというもの。`Producer-Extends and Consumer-Super`の略である。

余談だが、提供者か消費者かという対比は、コマンドクエリ分離原則(Command-Query Separation:CQS)のコマンドかクエリかということのアナロジーでは。絡めて覚えておくとよい。

[トップへ戻る](../../../../../../../README.md)