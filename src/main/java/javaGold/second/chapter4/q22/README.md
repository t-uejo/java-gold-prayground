# なぜラムダ式で副作用のある処理を避けるべきなのか

ラムダ式内は実質的finalであり、副作用のある処理は基本的に書くことができない。

しかし、ラムダ式外部で定義した`StringBuilder`やListコレクションにラムダ式内でaddしているような処理は、ラムダ式の定義前と後でオブジェクトの状態が変わり、副作用があると言える。（実質的finalだけれど参照先を変えていないのでできてしまう）

書籍では、このような副作用のあるラムダ式を書くべきではないとして、その理由を以下のように述べている。

> ラムダ式でこのような副作用のある処理を避けるべきなのは、ラムダ式は定義したタイミングではなく、ラムダ式が代入された関数型インターフェースのメソッドを呼び出したときに実行される「遅延実行」という特性があるからです。

## 遅延実行とは

ここで遅延実行について明確にするにあたり、ラムダ式について確認する。

ラムダ式はあくまで匿名クラスをより簡略化した書き方であり、実際には以下のようにインターフェースの実装クラスを定義している。

```java
//ラムダ式
Consumer<String> c = (str) -> list.add(str);

//匿名クラス
Consumer<String> c = new Consumer(){
    public void accept(str){
        list.add(str);
    }
}
```

ここではあくまで、定義しているだけで、確かにこのプログラムが読まれた際に実行されるわけではないことが分かる。

ではどこで実行されるのかというと、以下のようにこのラムダ式のメソッドを呼び出した時である。これを遅延実行と呼んでいる。

```java
public class LazyExecute{
    public static void execute(Consumer<String> c){
        c.accept("Hello"); //このタイミングでラムダ式が実行される
    }
}
```

このような遅延実行という性質があるため、どのような引数を`str`に渡すかは外部にゆだねられる。ラムダ式定義側から見ると結果に予測がつかない。そのため避けるべきである。

[トップへ戻る](../../../../../../../README.md)