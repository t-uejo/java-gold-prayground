# なぜインナークラスを使うのか

端的に述べると**情報隠蔽の強化**のため。<br>
書籍では、あるクラスがパッケージプライベートであっても、長期にわたって運用されるソフトウェアの場合、想定していなかったクラスから使われる可能性があると述べられている。

例えば、今回のようなリポジトリパターンを想定した場合、リスコフの置換原則に違反するため、Oracleクラスのインスタンス生成は避けるべきであるが、現状できてしまう。
[Factory](Factory.java)のインナークラスのように隠蔽して、getStrategy経由でインスタンス化させることで、他パッケージ、及び他クラスからは実現クラスを定義できず、リスコフの置換原則に違反するコードをそもそも書けない仕組みにできる。

また、上記の隠蔽の強化に加えて、書籍では、カプセル化の強化ができると述べられている。今回の場合、すべての実現クラスを一か所に集約できるので、複数のファイルにまたがるよりも管理が楽であり、参照もしやすい。

ただ、デメリットとしては、インナークラスが増えて、各メンバーの定義が増えていくと神クラスになる恐れもある。基本的に適切にクラス設計をすれば数行程度に済むという話もあるが、将来的に可読性が落ちて保守性が悪くなる恐れがある。特に今回のようなRepositoryパターンで各実装クラスをインナークラス化するのは避けた方が良い。（SQLなどが書かれる長大なクラスになることが予想されるため）

[トップへ戻る](../../../../../../../README.md)